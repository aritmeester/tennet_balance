from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, Any

SPEC_PATH = Path("openapi-spec.json")
OUTPUT_PATH = Path(
    "custom_components/tennet_balance/generated_points.py"
)

# Keys that are not actual sensor values
EXCLUDED_KEYS = {
    "sequence",
    "timeInterval_start",
    "timeInterval_end",
}

def prettify_name(key: str) -> str:
    replacements = {
        "afrr": "AFRR",
        "mfrr": "mFRR",
        "mfrrda": "mFRRda",
        "igcc": "IGCC",
        "mari": "MARI",
        "picasso": "PICASSO",
        "upw": "UPW",
    }

    parts = key.split("_")
    pretty_parts = []

    for part in parts:
        lower = part.lower()
        pretty_parts.append(replacements.get(lower, part.capitalize()))

    return " ".join(pretty_parts)

def load_points_properties(spec: Dict[str, Any]) -> Dict[str, Any]:
    try:
        return (
            spec["components"]["schemas"]["response_json"]["properties"]
            ["Response"]["properties"]["TimeSeries"]["items"]["properties"]
            ["Period"]["items"]["properties"]["points"]["items"]["properties"]
        )
    except KeyError as exc:
        raise RuntimeError(
            "OpenAPI spec structure changed, cannot locate points properties"
        ) from exc

def main() -> None:
    if not SPEC_PATH.exists():
        raise FileNotFoundError(
            f"OpenAPI spec not found at {SPEC_PATH.resolve()}"
        )

    spec: Dict[str, Any] = json.loads(SPEC_PATH.read_text())
    points_props = load_points_properties(spec)

    sensor_keys = sorted(
        key for key in points_props.keys()
        if key not in EXCLUDED_KEYS
    )

    if not sensor_keys:
        raise RuntimeError("No sensor keys found, generation aborted")

    lines = [
        "# This file is auto-generated by scripts/generate_points.py",
        "# Do not edit manually",
        "",
        "from __future__ import annotations",
        "",
        "from typing import Dict",
        "",
        "GENERATED_SENSOR_DESCRIPTIONS: Dict[str, Dict[str, str]] = {",
    ]

    for key in sensor_keys:
        name = prettify_name(key)
        lines.append(
            f'    "{key}": {{"name": "{name}"}},'
        )

    lines.append("}")

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text("\n".join(lines), encoding="utf-8")

    print(f"Generated {len(sensor_keys)} sensors")

if __name__ == "__main__":
    main()
